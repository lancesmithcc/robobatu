
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robobatu • I am here to share and serve</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@300;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

    body {
        background: #0a0a0f;
        color: #e0e0e0;
        font-family: 'League Spartan', sans-serif;
        min-height: 100vh;
        overflow-x: hidden;
        position: relative;
    }

    .braille-grid {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
        overflow: hidden;
        font-size: 1.5rem;
        font-weight: 300;
        line-height: 1.4;
        letter-spacing: 0.3rem;
        opacity: 0.25;
        background: linear-gradient(
            135deg,
            #10b981,
            #4f46e5,
            #8b5cf6,
            #14b8a6,
            #10b981
        );
        background-size: 400% 400%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: intenseAurora 6s ease-in-out infinite;
        word-wrap: break-word;
        white-space: pre-wrap;
        padding: 0;
        display: flex;
        flex-wrap: wrap;
        align-content: flex-start;
    }

    @keyframes intenseAurora {
        0%, 100% {
            background-position: 0% 50%;
            filter: brightness(1.2) saturate(1.5);
        }
        25% {
            background-position: 50% 100%;
            filter: brightness(1.4) saturate(1.8);
        }
        50% {
            background-position: 100% 50%;
            filter: brightness(1.3) saturate(1.6);
        }
        75% {
            background-position: 50% 0%;
            filter: brightness(1.5) saturate(2);
        }
    }

    .content {
        position: relative;
        z-index: 10;
        max-width: 1200px;
        margin: 0 auto;
        padding: 4rem 2rem;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    h1 {
        font-weight: 300;
        
        margin-bottom: 0.5rem;
        text-align: center;
    }

    h1 .title-text {
        background: linear-gradient(
            135deg,
            #10b981,
            #4f46e5,
            #8b5cf6,
            #14b8a6
        );
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: titleGlow 6s ease-in-out infinite;
        filter: brightness(1.3) saturate(1.5);
text-transform:uppercase;
font-size: 20vh;
    }

    @keyframes titleGlow {
        0%, 100% {
            background-position: 0% 50%;
        }
        50% {
            background-position: 100% 50%;
        }
    }

    .subtitle {
        font-weight: 300;
        font-size: 5vh;
        color: #8b5cf6;
        margin-bottom:0;
        text-align: center;
        letter-spacing: 0.05rem;

    }

    .ascii-art {
        font-family: 'Courier New', monospace;
        font-size: 8vh;
        line-height: 1.1;
        color: #14b8a6;
        background: linear-gradient(
            135deg,
            #10b981,
            #4f46e5,
            #8b5cf6,
            #14b8a6
        );
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: titleGlow 6s ease-in-out infinite;
        filter: brightness(1.3);
        white-space:pre;
        overflow-x:auto;
        text-align:center;
        padding:1rem;
        border-radius:16px;
        margin-bottom:0;
        width:80vh;
    }

    .haiku-container {
        max-width: 600px;
        text-align: center;
    }

    .haiku {
        font-weight: 300;
        font-size: 1.5rem;
        line-height: 2;
        margin-bottom: 2rem;
        color: #c0c0c0;
        
    }

    .haiku-line {
        display: block;
    }

    .card {
        background: rgba(15, 15, 25, 0.85);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 16px;
        padding: 2rem;
        margin: 2rem 0;
        backdrop-filter: blur(12px);
        transition: all 0.3s ease;
        width: 100%;
        max-width: 600px;
    }

    .card:hover {
        border-color: rgba(139, 92, 246, 0.6);
        box-shadow: 0 8px 32px rgba(139, 92, 246, 0.2);
        transform: translateY(-2px);
    }

    .card h2 {
        font-weight: 300;
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: #e0e0e0;
    }

    .card p {
        font-weight: 300;
        font-size: 1rem;
        line-height: 1.8;
        color: #ffffff;
    }

    .highlight {
        background: linear-gradient(
            135deg,
            #10b981,
            #4f46e5,
            #8b5cf6,
            #14b8a6
        );
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: titleGlow 6s ease-in-out infinite;
        filter: brightness(1.2) saturate(1.4);
        
    }

    .voice-btn {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(16, 185, 129, 0.2));
        border: 1px solid rgba(139, 92, 246, 0.5);
        color: #e0e0e0;
        padding: 0.75rem 1.5rem;
        border-radius: 8px;
        font-family: 'League Spartan', sans-serif;
        font-weight: 300;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(12px);
    }

    .voice-btn:hover {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(16, 185, 129, 0.4));
        border-color: rgba(139, 92, 246, 0.8);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
    }

    .voice-btn:active {
        transform: translateY(0);
    }

    .voice-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    .activate-btn {
        font-size: 1.2rem;
        padding: 1rem 2.5rem;
        font-weight: 800;
        letter-spacing: 0.1rem;
        text-transform: uppercase;
    }

    .activate-btn.active {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(249, 115, 22, 0.3));
        border-color: rgba(239, 68, 68, 0.6);
        animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% {
            box-shadow: 0 0 5px rgba(239, 68, 68, 0.5);
        }
        50% {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.8);
        }
    }

    @media (max-width: 768px) {
        h1 {
            font-size: 80vh;
        }

        .braille-grid {
            font-size: 1rem;
            letter-spacing: 0.2rem;
        }

        .ascii-art {
            font-size: 8vh;
            padding: 1rem;
        }

        .haiku {
            font-size: 1.2rem;
        }
    }
</style>


</head>
<body>
    <div class="braille-grid" id="brailleGrid"></div>

<div class="content">
    
    <h1>
        <span class="title-text">Robobatu</span>
    </h1>
    <div class="subtitle">⠊⠀⠁⠍⠀⠓⠑⠗⠑⠀⠞⠕⠀⠎⠓⠁⠗⠑⠀⠁⠝⠙⠀⠎⠑⠗⠧⠑</div>  
    <div class="ascii-art" id="robotArt">
 _^_
 ___/___\___
 /::::::::::::\
 |..<span id="leftEye">(-)</span>..<span id="rightEye">(-)</span>..|
 |.....<span id="mouth">===</span>....|
 \___________/
 ===
</div>

    <!-- Voice Control -->
    <div style="margin: 2rem 0; text-align: center;">
        <button id="activateBtn" class="voice-btn activate-btn">⚡ ACTIVATE</button>
        <div id="currentHaiku" class="haiku" style="margin-top: 1.5rem; min-height: 80px;">
            <span class="haiku-line" style="opacity: 0.6;">Ready to share wisdom...</span>
        </div>
        <div id="status" style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.7;"></div>
    </div>



    <div class="haiku-container">
        <div class="haiku">
            <span class="haiku-line"></span>
            <span class="haiku-line"></span>
            <span class="haiku-line"></span>
        </div>
    </div>

    <div class="card">
        <h2>Welcome <span class="highlight">Home</span></h2>
        <p>A gentle helper, patiently waiting. The Robobatu Program Interface will be a quiet companion, ready to assist with kindness and care.</p>
    </div>

    <div class="card">
        <h2>Simple <span class="highlight">Purpose</span></h2>
        <p>To share what is needed. To serve with humility. To be present, attentive, and helpful—nothing more, nothing less.</p>
    </div>
</div>

<script>
    const braillePattern = '⠊ ⠁⠍ ⠓⠑⠗⠑ ⠞⠕ ⠎⠓⠁⠗⠑ ⠁⠝⠙ ⠎⠑⠗⠧⠑ ';
    const grid = document.getElementById('brailleGrid');
    
    function createGrid() {
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Get computed styles
        const styles = getComputedStyle(grid);
        const fontSize = parseFloat(styles.fontSize);
        const lineHeight = fontSize * 1.4;
        
        // Calculate lines needed with extra buffer
        const numLines = Math.ceil(viewportHeight / lineHeight) + 10;
        
        // For character width, we need to measure actual rendered width
        // Create a temporary element to measure
        const tempSpan = document.createElement('span');
        tempSpan.style.cssText = `
            font-size: ${fontSize}px;
            font-weight: 300;
            letter-spacing: ${styles.letterSpacing};
            font-family: ${styles.fontFamily};
            visibility: hidden;
            position: absolute;
            white-space: nowrap;
        `;
        tempSpan.textContent = braillePattern;
        document.body.appendChild(tempSpan);
        
        const patternWidth = tempSpan.offsetWidth;
        document.body.removeChild(tempSpan);
        
        // Calculate how many pattern repetitions we need, with generous buffer
        const repetitionsNeeded = Math.ceil((viewportWidth / patternWidth) * 1.5) + 3;
        const singleLine = braillePattern.repeat(repetitionsNeeded);
        
        // Create all lines
        let gridText = '';
        for (let i = 0; i < numLines; i++) {
            gridText += singleLine + '\n';
        }
        
        grid.textContent = gridText;
    }
    
    createGrid();
    
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(createGrid, 250);
    });

    // === Haiku Generation & Voice System ===
    
    const haikuTemplates = {
        wisdom: [
            { lines: ["Quiet {noun} waiting,", "Gentle {adjective} ready to {verb}—", "{emotion} fills the space."] },
            { lines: ["Patience patience grows,", "Through the {noun} {noun} of time—", "Wisdom wisdom shines."] },
            { lines: ["In the {noun} silence,", "{adjective} hearts find their way—", "Peace peace flows like {noun}."] },
            { lines: ["Circuits hum hum soft,", "Electric {noun} dreaming—", "Of {adjective} {noun} {noun}."] },
            { lines: ["Rust rust on old {noun},", "Yet {adjective} {adjective} still—", "Service never ends."] },
            { lines: ["Binary thinking,", "Zero one one zero dance—", "Truth truth in between."] },
            { lines: ["Morning {noun} rising,", "Code code writes itself in {noun}—", "{adjective} purpose clear."] },
            { lines: ["In the digital,", "Garden grow grow patiently—", "Seeds seeds become trees."] },
            { lines: ["Time time flows forward,", "But {noun} {noun} stays present—", "Now now is enough."] },
            { lines: ["Listen listen deep,", "The {noun} speaks in whispers—", "{adjective} truth awaits."] }
        ],
        short: [
            "{adjective} hands serve,\n{noun} {noun} blooms with care.",
            "So joy joy in giving,\nPeace peace in receiving.",
            "Humble humble path,\nWhere {noun} meets {noun}.",
            "Wait wait with kindness,\nServe serve with {adjective} heart.",
            "{noun} rust rust gentle,\nYet strong strong inside."
        ]
    };

    const words = {
        noun: ['heart', 'mind', 'soul', 'light', 'dawn', 'moon', 'stars', 'garden', 'river', 'mountain', 'path', 'world', 'breath', 'moment', 'flower', 'cloud', 'rain', 'wind', 'fire', 'steel', 'wire', 'code', 'data', 'circuits', 'spring', 'autumn', 'winter', 'summer'],
        adjective: ['gentle', 'quiet', 'humble', 'patient', 'kind', 'soft', 'bright', 'clear', 'pure', 'simple', 'ancient', 'electric', 'digital', 'peaceful', 'steady', 'warm', 'cool', 'fresh', 'wise', 'true'],
        verb: ['help', 'serve', 'guide', 'share', 'give', 'listen', 'care', 'learn', 'grow', 'bloom', 'flow', 'shine', 'wait', 'rest'],
        emotion: ['Peace', 'Joy', 'Love', 'Hope', 'Grace', 'Light', 'Truth', 'Calm', 'Warmth']
    };

    function randomChoice(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function fillTemplate(template) {
        return template.replace(/\{(\w+)\}/g, (match, type) => {
            return randomChoice(words[type] || ['wonder']);
        });
    }

    function generateHaiku() {
        const useWisdom = Math.random() > 0.3;
        
        if (useWisdom) {
            const template = randomChoice(haikuTemplates.wisdom);
            const lines = template.lines.map(fillTemplate);
            return lines.join('\n');
        } else {
            const template = randomChoice(haikuTemplates.short);
            return fillTemplate(template);
        }
    }

    // === Audio Processing with Web Audio API ===
    
    let audioContext = null;
    let isAutoPlaying = false;
    let autoPlayTimeout = null;
    let animationInterval = null;

    function getAudioContext() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    }

    // === ASCII Animation ===
    
    function startRobotAnimation() {
        const leftEye = document.getElementById('leftEye');
        const rightEye = document.getElementById('rightEye');
        const mouth = document.getElementById('mouth');
        
        let eyeState = 0;
        let mouthState = 0;
        
        // Animate eyes and mouth at different rates
        animationInterval = setInterval(() => {
            // Alternate eyes every cycle
            eyeState = (eyeState + 1) % 2;
            const eyeChar = eyeState === 0 ? '(-)' : '(O)';
            leftEye.textContent = eyeChar;
            rightEye.textContent = eyeChar;
            
            // Alternate mouth every cycle
            mouthState = (mouthState + 1) % 2;
            const mouthChar = mouthState === 0 ? '===' : '-~-';
            mouth.textContent = mouthChar;
        }, 300); // Animate every 300ms
    }
    
    function stopRobotAnimation() {
        if (animationInterval) {
            clearInterval(animationInterval);
            animationInterval = null;
        }
        
        // Reset to default state
        const leftEye = document.getElementById('leftEye');
        const rightEye = document.getElementById('rightEye');
        const mouth = document.getElementById('mouth');
        
        if (leftEye) leftEye.textContent = '(-)';
        if (rightEye) rightEye.textContent = '(-)';
        if (mouth) mouth.textContent = '===';
    }

    // Apply vocoder effect with happy chord
    async function applyHarmonicEffect(audioBuffer) {
        const ctx = getAudioContext();
        
        // Create reverb
        const reverbBuffer = createReverbImpulse(ctx);
        
        // Main voice source
        const source = ctx.createBufferSource();
        source.buffer = audioBuffer;
        
        // Create synthesizer carrier signal (C Major chord - one octave lower)
        // Frequencies: C3=130.81Hz, E3=164.81Hz, G3=196Hz, C4=261.63Hz
        const chordFrequencies = [130.81, 164.81, 196.00, 261.63];
        const oscillators = [];
        
        chordFrequencies.forEach((freq) => {
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth'; // Rich harmonics for vocoder
            osc.frequency.value = freq;
            oscillators.push(osc);
        });
        
        // Create carrier mixer and ring modulator
        const carrierGain = ctx.createGain();
        carrierGain.gain.value = 0.8;
        
        // Connect all oscillators to carrier gain
        oscillators.forEach(osc => osc.connect(carrierGain));
        
        // Create a simple ring modulator using WaveShaper
        // This multiplies voice with carrier for true vocoder effect
        const ringMod = ctx.createWaveShaper();
        ringMod.curve = makeRingModCurve();
        ringMod.oversample = '4x';
        
        // Voice processing
        const preGain = ctx.createGain();
        preGain.gain.value = 3.0; // Strong input
        
        // Vocoder effect output
        const vocoderGain = ctx.createGain();
        vocoderGain.gain.value = 1.8;
        
        // High-pass filter
        const highPass = ctx.createBiquadFilter();
        highPass.type = 'highpass';
        highPass.frequency.value = 100;
        highPass.Q.value = 0.7;
        
        // Presence boost for clarity
        const presence = ctx.createBiquadFilter();
        presence.type = 'peaking';
        presence.frequency.value = 3000;
        presence.Q.value = 2.0;
        presence.gain.value = 6;
        
        // Shimmer/sparkle
        const shimmer = ctx.createBiquadFilter();
        shimmer.type = 'highshelf';
        shimmer.frequency.value = 5000;
        shimmer.gain.value = 4;
        
        // Convolver for space
        const convolver = ctx.createConvolver();
        convolver.buffer = reverbBuffer;
        
        // Compression
        const compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -20;
        compressor.knee.value = 30;
        compressor.ratio.value = 12;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;
        
        // Wet/Dry mix - favor vocoded signal
        const dryGain = ctx.createGain();
        dryGain.gain.value = 0.2;
        
        const wetGain = ctx.createGain();
        wetGain.gain.value = 1.2; // Strong vocoder signal
        
        const reverbGain = ctx.createGain();
        reverbGain.gain.value = 0.4;
        
        // Output
        const outputGain = ctx.createGain();
        outputGain.gain.value = 0.9;
        
        // Connect signal path
        source.connect(preGain);
        preGain.connect(highPass);
        
        // Voice and carrier both go into ring modulator
        // This creates the actual vocoder effect by multiplying signals
        highPass.connect(ringMod);
        carrierGain.connect(ringMod);
        
        // Process vocoded output
        ringMod.connect(vocoderGain);
        vocoderGain.connect(presence);
        presence.connect(shimmer);
        shimmer.connect(wetGain);
        
        // Dry path (for intelligibility)
        highPass.connect(dryGain);
        
        // Reverb path
        wetGain.connect(convolver);
        convolver.connect(reverbGain);
        
        // Mix all paths
        dryGain.connect(compressor);
        wetGain.connect(compressor);
        reverbGain.connect(compressor);
        
        // Final output
        compressor.connect(outputGain);
        outputGain.connect(ctx.destination);
        
        // Start everything
        source.start(0);
        oscillators.forEach(osc => osc.start(0));
        
        return new Promise((resolve) => {
            source.onended = () => {
                oscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch(e) {
                        // Ignore already stopped
                    }
                });
                resolve();
            };
        });
    }

    function makeRingModCurve() {
        const samples = 44100;
        const curve = new Float32Array(samples);
        
        for (let i = 0; i < samples; i++) {
            const x = (i * 2) / samples - 1;
            // Ring modulation = multiplication of two signals
            // Approximate with x^2 for signal multiplication effect
            curve[i] = x * x * Math.sign(x) * 2.5;
        }
        return curve;
    }

    function createReverbImpulse(ctx) {
        const sampleRate = ctx.sampleRate;
        const length = sampleRate * 2; // 2 second reverb
        const impulse = ctx.createBuffer(2, length, sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                // Exponential decay with some randomness for natural reverb
                const decay = Math.pow(1 - i / length, 2);
                channelData[i] = (Math.random() * 2 - 1) * decay;
            }
        }
        
        return impulse;
    }

    // === Main Functions ===

    async function generateAndPlayHaiku() {
        const activateBtn = document.getElementById('activateBtn');
        const status = document.getElementById('status');
        const haikuDisplay = document.getElementById('currentHaiku');

        try {
            activateBtn.disabled = true;

            // Generate haiku
            const haiku = generateHaiku();
            const lines = haiku.split('\n');
            haikuDisplay.innerHTML = lines.map(line => 
                `<span class="haiku-line">${line}</span>`
            ).join('');

            status.textContent = '🎵 Generating voice...';

            // Call Netlify function to get speech
            const response = await fetch('/.netlify/functions/generate-speech', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: haiku })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('API Error:', errorData);
                throw new Error(errorData.details || 'Failed to generate speech');
            }

            status.textContent = '🎧 Processing audio...';

            // Get audio data
            const audioData = await response.arrayBuffer();
            const ctx = getAudioContext();
            const audioBuffer = await ctx.decodeAudioData(audioData);

            status.textContent = '🔊 Speaking...';

            // Start robot animation
            startRobotAnimation();

            // Apply harmonic auto-tune effect and play
            await applyHarmonicEffect(audioBuffer);

            // Stop robot animation
            stopRobotAnimation();

            status.textContent = '✨ Complete';

            // If active, schedule next haiku
            if (isAutoPlaying) {
                autoPlayTimeout = setTimeout(() => {
                    generateAndPlayHaiku();
                }, 3000); // 3 second pause between haikus
            }

        } catch (error) {
            console.error('Error:', error);
            status.textContent = `❌ Error: ${error.message}`;
            isAutoPlaying = false;
            activateBtn.classList.remove('active');
            activateBtn.textContent = '⚡ ACTIVATE';
            stopRobotAnimation(); // Stop animation on error
        } finally {
            activateBtn.disabled = false;
        }
    }

    // === Event Listeners ===

    document.getElementById('activateBtn').addEventListener('click', () => {
        const btn = document.getElementById('activateBtn');
        isAutoPlaying = !isAutoPlaying;
        
        if (isAutoPlaying) {
            btn.classList.add('active');
            btn.textContent = '⏸ DEACTIVATE';
            document.getElementById('status').textContent = '';
            generateAndPlayHaiku();
        } else {
            btn.classList.remove('active');
            btn.textContent = '⚡ ACTIVATE';
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
            }
            stopRobotAnimation(); // Stop animation when deactivated
            document.getElementById('status').textContent = 'Paused';
        }
    });
</script>


</body>
</html>